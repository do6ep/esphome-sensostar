esphome:
  # Name of the ESP32-S3 device
  name: sensostar
  friendly_name: SensoStar
  comment: SensoStar Energy Meter
  name_add_mac_suffix: true
  project:
    name: "do6ep.SensoStar_Energy_Meter"
    version: 1.0.2

  # PlatformIO build options
  platformio_options:
    build_flags: -DBOARD_HAS_PSRAM
    board_build.arduino.memory_type: qio_opi
    board_build.f_flash: 80000000L
    board_build.flash_mode: qio

  on_boot:
    then:
      - output.turn_on: adc_control  # IO8 HIGH at boot
      - script.execute: read_adc_script  # Immediately read ADC once at boot
      - delay: 2000ms  # Kurze Wartezeit, damit WLAN-Status gesetzt wird
      - lambda: |-
          if (!id(wifi_connected)) {
            id(ap_mode_blink).execute();
          }      
      - if:
          condition:
            switch.is_on: mqtt_client_switch
          then:
            - wait_until:
                condition:
                  wifi.connected: {}
                timeout: 60s   # Warte bis 60 Sekunden, bis WLAN verbunden ist
            - mqtt.enable
            - logger.log: "MQTT beim Start aktiviert"
          else:
            - mqtt.disable
            - logger.log: "MQTT beim Start deaktiviert"
    
# Configuration for Xaio ESP32S3
esp32:
  board: esp32-s3-devkitc-1
  cpu_frequency: 80MHZ  # keep the CPU cool
  framework:
    type: esp-idf

# activate PSRAM for ESPHome
psram:
  mode: octal
  speed: 80MHz

# Enable logging
logger:
  level: debug

#  level: info
  logs:
    light: info
#  hardware_uart: USB_CDC

api:
  encryption:
    key: !secret api_encryption_key # create use openssl rand -base64 32

ota:
  platform: esphome

# Disable onboard bluetooth (powersave / because its not used)
esp32_ble:
  enable_on_boot: False

wifi:
# Uncomment this if you have ented your credentials in the secrets.yaml
# anyway at least the api_encryption_key: section must be present in the secrets.yaml
#  ssid: !secret wifi_ssid
#  password: !secret wifi_password

  ssid: "SensoStar"
  reboot_timeout: 0s 
  output_power: 16.5dB  # reduce WLAN Power to keep the CPU cool or increment to 20.5dB if needed
  enable_btm: true
  enable_rrm: true
  power_save_mode: none
  fast_connect: false

  on_connect:
    - script.stop: ap_mode_blink
    - output.turn_on: wifi_led
  on_disconnect:
    - script.execute: ap_mode_blink

  # Optional manual IP
  #manual_ip:
  #  static_ip: 192.168.230.114
  #  gateway: 192.168.230.1
  #  subnet: 255.255.255.0
  #  dns1: 192.168.230.1

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "SensoStar Fallback Hotspot"
    password: "01234567"  # please change pasword for fallback hotspot

# Captive portal configuration
captive_portal:

web_server:
  version: 3
  port: 80

mqtt:
  id: mqtt_client
  broker: ""      # IP of your MQTT-Host, will be set trough GUI
  username: ""    # MQTT User Name, will be set trough GUI
  password: ""    # MQTT Password, will be set trough GUI
  enable_on_boot: false
  keepalive: 15s

external_components:
  - source:
      #type: local
      #path: !secret local_path
      type: git                                         # Be careful ESPhome is caching the repository. Do the following to update the cache
      url: https://github.com/do6ep/esphome-sensostar    # Deleting the .esphome/external_components/ cache, or 
      ref: main  # or a specific commit SHA             # Using a ref: to pin to a specific commit or branch.
    components: [ SensoStar_MBus ]

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Amsterdam
    servers: ["0.de.pool.ntp.org", "1.de.pool.ntp.org", "2.de.pool.ntp.org"]

uart:
  - id: uart_mbus
    tx_pin: GPIO43
    rx_pin: GPIO44
    baud_rate: 2400
    parity: EVEN
    
SensoStar_MBus:
  id: sensostar_id
  uart_id: uart_mbus
  update_interval: 10s
  data_led: mbus_data_led # Add this line, linking to the output below

sensor:
  - platform: SensoStar_MBus
    energy:
      name: "SensoStar Energy"
    volume:
      name: "SensoStar Volume"
    power:
      name: "SensoStar Power"
    flow:
      name: "SensoStar Flow"
    temperature_flow:
      name: "SensoStar Flow Temperature"
    temperature_return:
      name: "SensoStar Return Temperature"
    temperature_diff:
      name: "SensoStar Temperature Difference"
    calculated_power:
      name: "SensoStar Calculated Power"

  - platform: adc
    pin: GPIO7
    id: adc_input_sensor
    name: "SensoStar Battery Voltage"
    update_interval: never  # done by interval
    filters:
      - lambda: return x * 3.6; # Vbat is measured via a resistive divider 39k--o--15k

  - platform: template
    name: "SensoStar Battery Level"
    device_class: battery
    unit_of_measurement: "%"
  #  internal: true  # hide from Home Assistant unless needed
    accuracy_decimals: 0
    update_interval: 60s
    lambda: |-
      // Min- und Max-Spannung Batterie
      const float min_voltage = 2.0;    // Spannung bei fast leer
      const float max_voltage = 3.2;    // volle Spannung

      float voltage = id(adc_input_sensor).state;
      if (voltage < min_voltage)
        return 0;
      if (voltage > max_voltage)
        return 100;

      float percent = (voltage - min_voltage) * 100.0 / (max_voltage - min_voltage);
      return (int)percent;

  - platform: internal_temperature
    name: "SensoStar ESP32 Internal Temperature"
    id: esp32_internal_temp
    update_interval: 60s      

  - platform: wifi_signal
    name: "SensoStar WiFi Signal"
    id: wifi_signal_sensor
    update_interval: 60s

  - platform: debug
    loop_time:
      name: "SensoStar ESP32 Loop Time"    

debug:
  update_interval: 5s

text_sensor:
  - platform: SensoStar_MBus
    status:
      name: "SensoStar Status"

  - platform: debug
    device:
      name: "SensoStar Device Info"

output:
  - platform: gpio
    pin:
      number: GPIO8
      inverted: false
    id: adc_control
  - platform: gpio
    pin: 
      number: GPIO1
      inverted: true
    id: mbus_data_led
  - platform: gpio
    pin: 
      number: GPIO2
      inverted: true
    id: wifi_led
  - platform: gpio
    pin:
      number: GPIO21 # builtin LED
      inverted: true
    id: heartbeat_output 
 
script:
  - id: read_adc_script
    then:
      - output.turn_off: adc_control     # Set IO1 LOW
      - delay: 8ms  # wait until the capacitor on the resistive divider is charged
      - component.update: adc_input_sensor  # Trigger ADC read
      - output.turn_on: adc_control      # Set IO1 HIGH

  - id: ap_mode_blink
    mode: restart
    then:
      - logger.log: "AP mode blinking started"
      - while:
            condition:
              lambda: 'return !id(wifi_connected);'
            then:
              - output.turn_on: wifi_led
              - delay: 200ms
              - output.turn_off: wifi_led
              - delay: 1000ms

interval:
  - interval: 600s
    then:
      - script.execute: read_adc_script
  - interval: 5s
    then:
      - light.turn_on: heartbeat_led
      - delay: 500ms
      - light.turn_off: heartbeat_led      

button:
  - platform: template
    name: "Read battery level now"
    on_press:
      then:
        - script.execute: read_adc_script
  - platform: template
    name: "Read WiFi Signal now"
    entity_category: diagnostic
    on_press:
      then:
        - component.update: wifi_signal_sensor
  - platform: restart
    name: "SensoStar restart ESP"
    id: restart_esp

switch:
  - platform: template
    name: " MQTT enabled"
    id: mqtt_client_switch
    restore_mode: RESTORE_DEFAULT_OFF  # Status nach Neustart beibehalten, hier Standard OFF
    entity_category: config
    optimistic: true
    turn_on_action:
      - wait_until:
          condition:
            wifi.connected: {}
          timeout: 60s   # Warte bis 60 Sekunden, bis WLAN verbunden ist
    #  - mqtt.enable
    #  - logger.log: "MQTT aktiviert"
      - lambda: |-
          // Get values from text/number inputs
          std::string addr = id(mqtt_client_address_text).state;
          uint16_t port = (uint16_t)atoi(id(mqtt_client_port_text).state.c_str());

          // Validate broker address
          if (addr.empty()) {
            ESP_LOGW("mqtt", "Cannot enable MQTT: broker address is empty");
            id(mqtt_client_switch).turn_off();
            return;
          }

          // Validate port
          if (port < 1 || port > 65535) {
            ESP_LOGW("mqtt", "Cannot enable MQTT: invalid port %d", port);
            id(mqtt_client_switch).turn_off();
            return;
          }

          // All checks passed, enable MQTT
          id(mqtt_client).set_broker_address(addr.c_str());
          id(mqtt_client).set_broker_port(port);
          id(mqtt_client).set_username(id(mqtt_username_text).state.c_str());
          id(mqtt_client).set_password(id(mqtt_password_text).state.c_str());
          id(mqtt_client).enable();
          ESP_LOGI("mqtt", "MQTT enabled on %s:%d", addr.c_str(), port);

    turn_off_action:
      - mqtt.disable
      - logger.log: "MQTT deaktiviert"

text:
  - platform: template
    mode: text
    name: "1. MQTT broker address"
    id: mqtt_client_address_text
    icon: "mdi:text"
    entity_category: config
    initial_value: ""
    restore_value: true
    optimistic: true
    internal: false  # hide from Home Assistant unless needed
    on_value:
      then:
        - logger.log:
            format: "%s"
            args: ["x.c_str()"]
        - lambda: |-
            id(mqtt_client).set_broker_address(x.c_str());
            ESP_LOGI("mqtt", "MQTT broker set to %s", x.c_str()); 

  - platform: template
    mode: text
    name: "2. MQTT port"
    id: mqtt_client_port_text
    icon: "mdi:text"
    entity_category: config
    initial_value: "1883"
    restore_value: true
    optimistic: true
    internal: false  # hide from Home Assistant unless needed
    on_value:
        then:
          - logger.log:
              format: "%s"
              args: ["x.c_str()"]  
          - lambda: |-
              // Convert string to integer
              uint16_t port = (uint16_t) atoi(x.c_str());
              // Safety check (valid range for MQTT ports)
              if (port < 1 || port > 65535) {
                ESP_LOGW("mqtt", "Invalid port %d, ignoring", port);
              } else {
                id(mqtt_client).set_broker_port(port);
                ESP_LOGI("mqtt", "MQTT Port set to %d", port);
              }

  - platform: template
    mode: text
    name: "3. MQTT Username"
    id: mqtt_username_text
    icon: "mdi:text"
    entity_category: config
    initial_value: "mqtt-user"
    restore_value: true
    optimistic: true
    internal: false  # hide from Home Assistant unless needed
    on_value:
      then:
        - logger.log:
            format: "%s"
            args: ["x.c_str()"]  
        - lambda: |-
            id(mqtt_client).set_username(x.c_str());  
            ESP_LOGI("mqtt", "MQTT user set to %s", x.c_str());  

  - platform: template
    mode: password
    name: "4. MQTT Password"
    id: mqtt_password_text
    icon: "mdi:text"
    entity_category: config
    initial_value: "mqtt-password"
    restore_value: true
    optimistic: true
    internal: false  # hide from Home Assistant unless needed
    on_value:
      then:
        - logger.log:
            format: "%s"
            args: ["x.c_str()"]   
        - lambda: |-
            id(mqtt_client).set_password(x.c_str());
            ESP_LOGI("mqtt", "MQTT password set to %s", x.c_str());  

light:
  - platform: binary
    id: heartbeat_led
    output: heartbeat_output
    internal: true  # hide from Home Assistant unless needed
    
binary_sensor:
  - platform: status
    name: "ESP Status"
    id: esp_status
    internal: true  # hide from Home Assistant unless needed

  - platform: status
    name: "MQTT connected"
    id: mqtt_connection_status

globals:
  - id: wifi_connected
    type: bool
    restore_value: no
    initial_value: 'false'
